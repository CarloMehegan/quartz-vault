tags: #notes #fleeting
creation date: [[2022-09-05 Monday]] 21:03:45
description:: why is swdev challenging, YAPL

from piazza:
9/6: M1, Lesson 2 Why is SWDev challenging, + Lesson 3 Learning YAPL, Project 1 assignment

no class thursday
video on blackboard about starting java coding

## Why is Software Development challenging?
no repitition in an academic environment always learning something new

Three basic steps in a sw project
- Analysis - figure out what needs to be done
	- could be formalized into a product requirements document
- Design - figure out how to do this
	- software architecture, infrastructure
	- different roles, software developer vs software architect
- Implementation - just do it (right)
	- software

the Waterfall process model
requirements - design - implementation - verification - maintenance
bad - cant go back up the waterfall - difficult to change design during implementation phase

#quote
From Steve McConnell, [[Code Complete]] 2e
Percentages of development time
In small projects, construction activities dominate
In large projects, architecture, system testing, design takes up a larger percentage of time
Want to make solid infrastructure to work with later, would be costly to change later on

The architectural design has a long term impact

examples of big software projects / memories of architectural problems
- Y2K bug
- Boeing Starliner spacecraft
	- "we dont know how many software errors we have"
	- reviewing all 1 million lines of code

from a Gartner study in 2012
- 6 frequently mentioned reasons for project failure
	- functionality issues
	- substantially late
	- poor quality
	- high cost variance
	- canceled after launch
	- rejected or not implemented for other reasons
- bigger projects with higher budgets have a larger failure rate

why is it so difficult to get this right?
- complexity, scale, productivity, change, ...

Illustration - the twisting torso skyscraper again
- real world
- real task
	- assumption: fixed over time
	- assumption: task well understood by customer
- understand and communicate task (analysis)
	- assumption: analyst fully understands task
	- assumption: specification complete and error free
- mapping into computer model (design)
	- assumption: design matches and refines spec
- making computer model work (code)
	- assumption: coding matches design, complete and error free
- enable people to work with computer model to solve real task
	- assumption: human-computer interface ok
	- assumption: functionality ok for real task
	- assumption: system fits into environment, interacts well
we can see theres a number of places in this workflow where things can go wrong, things can be tricky

agile software development
scrum project management + extreme programming
the millenial teamwork workflow stuff
Idea
- build software incrementally
- use short 1-4 week iterations
- keep development aligned with changing needs
start with outline, architectural deisgn, planning
- assess
- select
- review
- develop
repeat until project closed
if i have to learn about scrum one more time im gonna eat my backpack from the inside out
my god hes been talking about scrum for so long

graph - standish chaos report from 2015
- projects using agile method - 39% successful 52% challenged 9% failed
- waterfall method - 11% 60% 29%
- large and medium projects agile way more successful
- closest is in small projects agile success is 58% and waterfall success is 44%

what can we do?
- complexity
	- divide and conquer
	- assigning tasks to teams/people
	- best practices
- scalability
	- what techniques and tools to use
- productivity
	- hands on experience, communication, using tools
- change
	- being prepared for it

in this class - what can we do?
- Object Orientation
	- Understand and apply OO design concepts, design principles, ex encapsulation, inheritance, interfaces, ...
- Patterns
	- Get a reservoir of best practices and lessons learnt experiences that give concrete solutions for abstract problems
- Tools
	- Learn to work with professional tools to develop software and analyze software
- Case Study
	- Learn to work in a larger setting and apply issues above to a serious, real world application

#quote Steve McConnell
The metaphor of building software like building dog houses, houses, skyscrapers


## Learning yet another programming language
Programming - How do we get electrons to do the work?
- Problems
- Algorithms
- Language
- Machine Architecture
- Micro-architecture
- Logic Circuits
- Devices

There are key concepts we can see in almost all programming languages, similarities

Key concepts:
1. Hardware has separate units for integer & floating point arithmetic
2. Control flow
   Code resides in memory locations
   Program counter pc says where next instruction is
   Implicit vs Explicit 
   Implication for programming languages
   - control flow operators
   - if else, while, for, etc
3. Code organized in “blocks”
   putting lines of code together
   starting address, parameters, code, return statements
   operated in a call stack
   Implication for programming languages
   - code structured in methods/functions/procedures
   - recursion
4. Memory locations can be accessed for data
   heap space
   memory can be allocated and freed at runtime
   Implication for programming languages
   - command to allocate memory - in Java, `new <datatype>()`
   - command to release memory - in Java, automatic garbage collection
   - memory holds bit patterns - in Java, uses types to avoid confusion of what content is
   Implication for programming
   - need to initialize new entities with meaningful bit patterns
   - can create dynamic data structures - lists, trees, hash tables, etc. (man i forgot all about these)
5. Hardware has memory hierarchy, (volatile and persistent)
   visualized as a triangle
   top levels are fast, small, and volatile - CPU caches, main memory
   lower levels are slower, larger, and persistent - SSD, hard disk
   Implication for programming
   - address space resides in volatile memory at runtime
   - input data usually resides in "files" on persistent storage
   - need to have commands to work on persistent storage
	   - open files, read input from files, write output to files
	   - parse input and feed it into data structures in address space

wow all these words are like mush

programming languages naturally need to have a lot in common because of these key concepts
there is a need to structure large pieces of code
there is a need to reuse code
implication: mathod -> class -> package -> library

##### our to do list for learning java
- Program execution, life cycle
- Control flow
- Fundamental data structures
- Structure of large programs
- User interaction
- Persistent storage
- Special topics
	- concurrent execution
	- distributed / network applications
	- regular execution, error handling
- Object Orientation

more slides we didnt get to https://blackboard.wm.edu/bbcswebdav/pid-1894228-dt-content-rid-25593755_1/xid-25593755_1