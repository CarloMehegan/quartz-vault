tags: #notes #fleeting
creation date: [[2022-09-22 Thursday]] 11:04:47
description:: multithreading

career fair on friday

project 2
due oct 3
asked to implement an algorithm in an existing codebase
	given two maze building algorithms, asked to implement another
includes pdf describing terminology used
graded on use of issue tracker
develop your own junit tests
"big enough that you dont want to read all the files"
	how do we interface with the rest of the code base without understanding it all?
multithreading
	in the project - shows a loading screen while maze is generating
	talking about multithreading today


[[M2L3_MultiThreading_part1.key.pdf]]
## Intro to Multithreading - Part 1
Multithreading allows us to program parallel applications within a single process, a single executing application

##### potential benefits
- speed up
	- on a single processor architecture (with or without multiple cores)
	- on a multiprocessor architecture
- software design
	- for certain types of application, multithreading gives better class design
- UI responsiveness
	- gui remains responsive and interactive while heavy duty calculation lifted by background threads
also if you want to ex. back up a file every 20 seconds, this can be done using multithreading

##### what are threads?
- thread
	- program unit that is executed independently
	- belongs to a particular process
	- multiple threads of a process can run simultaneously
- virtual machine, runtime environment
	- executes thread for some time (eg a short time slice)
	- thread scheduler activates and deactivates threads
	- creates illusion of threads running in parallel
		- actually switching really fast
- multiprocessor / multicore architectures
	- threads can actually run in parallel

##### declaring and running threads
- high level recipe
	- define class that implements interface Runnable
	- Runnable has one method `void run()`
	- place thread action into run method
	- construct object of runnable class
	- construct thread from that object
	- start thread

##### thread ex.
- run two threads in parallel
- prints 10 greetings
- after each print, sleep for 100 ms
```Java
{
 System.out.println(i + ": " + greeting);
 Thread.sleep(100);
} 
```
all threads should occasionally **yield** control
- otherwise called selfish, could be cumbersome with scheduling
- stimulates scheduler and thread switch
	- `yield()`
	- `sleep(long ms)` throws InterruptedException


##### ex. 2 greeter threads
1 thread printing Hello and 1 thread printing Goodbye
![[Pasted image 20220922112926.png]]
"we use threads because we dont want to enforce what comes first, second, etc"
"if you want that control just code like normal"


##### life cycle of a thread in Java
![[Pasted image 20220922113248.png]]


##### states of a thread that isAlive()
different states between start() and termination
![[Pasted image 20220922113312.png]]
if sleeping or waiting, moved to Blocked state
moves to Runnable when sleep is over or done waiting
this is Thread Scheduling as Java VM sees it, more going on underneath

##### blocked thread state
- reasons for blocked state
	- sleeping
	- waiting to acquire lock
	- waiting for condition
- unblocks only if reason block goes away

##### scheduling threads
- scheduler activates new thread if
	- a thread has completed its time slice
	- a thread has blocked itself
	- a thread with higher priority has become runnable
- scheduler determines new thread to run
	- looks only at runnable threads
	- picks one with max priorities
		- priority is platform dependent
		- dont mess with (for now)

##### terminating threads
a natural death:
- thread terminates when run exits
- other thread may wait for it
	- option 1 `dyingThread.join()`
	- option 2 `while (dyingThread.isAlive()) { Thread.sleep(1000); }`

ways to kill a thread
1. murder: premature approach of early java versions
   like closing a window on your laptop
   stop method: (deprecated)
   do not use this method, leaves computation in uncontrolled/unclear state
2. request for suicide:
   we request the thread to terminate itself
   interrupt method
   - calling t.interrupt() doesnt actually interrupt t; just sets a flag
   - effect depends on thread program code
   - supposed behavior
	   - interrupted thread must sense interruption `boolean isInterrupted()`
	   - and exit its run method
   - interrupted thread has a chance to clean up

##### sensing interruptions
option 1
- thread could occasionally call `Thread.currentThread().isInterrupted()`

option 2
- thread could occasionally `sleep()`, or `wait()`
- both methods throw InterruptedException when thread interrupted
- ... and then the interruption status is cleared

option 2 is more robust
- sleep occasionally, catch exception and react to interruption
- **allows for clear separation of code**

recommendation
- terminate run when sensing interruption (common reaction)
- use variant 2
	- locate all code for cleaning up in `catch/finally` clause
	- enhance with variant 1 for lengthy methods without exceptions
	- make check with `isInterrupted throw InterruptedException`

```Java
public class MyRunnable implements Runnable
{
	public void run()
	{
		try
		{
			while (...)
			{
				// do work
				Thread.sleep(...);
			}
		}
		catch (InterruptedException e)
		{
			// clean up
		}
	}
}
```
üèÉ‚Äç‚ôÇÔ∏è, üò¥, ‚è∞

##### summary
create threads
assign work to a thread
terminate a thread
next:
communicate data between threads
	race condition
	locks and synchronized method calls


[[M2L3_MultiThreading_part2.key.pdf]]
## Intro to Multithreading - Part 2
theres example stuff im not gonna write it all out

typical situation in compositional approaches
- 1st step: get the components
	- define threads, get them running, make them terminate
- 2nd step: combine components to overall system
  Here: communication among threads?
	- in principle: simple, threads communicate via shared memory, ie objects
	- eg. explicitly via an object "messageQueue"
	- eg. implicitly via object that hold data and are accessed by several threads (not necessarily aware of one another)
	- in practice: **shared data must be handled with care!**

example: visitors to a garden counted at 2 turnstiles
threads A and B: read counter, increment value, update counter, do 20 times
```Java
for (i = 0 ; i < 20 ; i++)
{
	x = counter ; x++ ; counter = x ;
}
```
both threads communicate via shared counter
expect result of counter = 40
does it work
- often, but there is no quarantee
- occasionally see results like 32, 37, 39...

##### race condition
A race condition occurs if **the effect of multiple threads on shared data depends on the order in which threads are scheduled**.
- obviously a bad thing
	- common requirement - we want deterministic programs that reliably produce same correct output for same input
	- additional difficulty - detection of race condition, may be difficult to reproduce
	- essentially a nightmare for debugging and testing
- so we need
	- a design strategy to avoid race conditions.
	- a technical, language mean that helps us programming a solution
		- (what does that mean am i having a stroke)

##### solution to race conditions
- access to shared objects requires protection
	- mutual exclusion:
		- thread/process can access object or enter a critical code section **only one at a time**
		- generalization; at most $n$ threads/processes, common: $n$ reader, 1 writer
- key issue
	- thread can do that computation without being disturbed, without interference from others
- design strategy
	- check all classes, objects with read/write access to several threads
	- use encapsulation and restrict access
- in java
	- synchronize access to shared objects to have at most $n$ threads access data
	- means to describe that: **Locks**
	- important - concept should avoid busy waiting (which is the case here)!

##### object locks
- each object in Java has a lock
- lock activated with keyword "`synchronized`"
- calling a synchronized method - acquires lock of implicit parameter
- leaving the synchronized method - releases lock
- easier than explicit Lock objects - but granularity fixed to method calls!
```Java
{
	public synchronized void add(E newValue) { . . . }
	public synchronized E remove() { . . . }
	. . .
}
```

##### summary
create threads
assign work to a thread
terminate a thread
communicate data between threads
	shared memory, shared objects
	race condition
	locks and synchronized method calls

##### challenges in testing a multithreaded class
see last slide i dont wanna write it out

##### for project 2
asked to test code that runs in background thread
typically with testing create object, perform operations, see if it checks out
background threads complicate this, test is running faster than background thread
- our maze building algorithm operates on a background thread
- test code executes on a different thread
have to use order() to order a maze
we have method waitTillDelivered() for waiting during testing
uhh idk im not following anymore look at MazeFactory.java for fully implemented class
"challenge is to implement a not so easy algorithm, making it fit in isnt as hard" (we can see the other two algorithms already implemented)
"challenge is to write meaningful tests cases"
