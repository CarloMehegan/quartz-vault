tags: #notes #fleeting  
creation date: [[2022-11-16 Wednesday]] 11:09:01  
description:: solving problems recursively again

solving problems recursively

ex. What is the largest number of slices of pizza we can get with $n$ straight cuts using a pizza knife? or equivalently, what is the maximum number of regions created by $n$ straight lines?  
  
isnt it infinite i dont get it  
oh the cuts are limited yeah yeah  
  
Let $L_n$ be the answer. $L_0 = 1$ and $L_1 = 2$  
Assume now that I have already $n-1$ lines which create $L_{n-1}$ regions.  
To maximize the cuts, and thus the new pieces, the new $n$th line should cross all previous ones. Let the new line cross the previous ones in that order: $i_1, i_2, \ldots , i_{n-1}$.

The exterior regions before the new line crosses $i_1$ and after crossing $i_{n-1}$ are separated into two regions. The $n-2$ interior regions defined between $i_k$ and $i_{k+1}$ are also now separated into two regions by the new line. Since we introduce 2 new regions but lose 1 older one, we have

$L_n = L_{n-1} + 2n - n = L_{n-1} + n$, for $n \geq 1$.
Then, $L_n = L_{n-1} + n = L_{n-1} + (n-1) + n = \ldots$
$= L_0 + 1 + 2 + ... + (n-1) + n$
baby gauss
$= 1 + \frac 1 2 n (n+1)$


ex. Print the power set of a given set $\{a_1, \ldots, a_n\}$. Given the power set of $\{a_1, \ldots, a_{n-1}\}$, $P_{n-1}$, the power set of $P_n$ is $P_{n-1} \cup \{\{X, a_n\}, X \in P_{n-1}\}$. The base case is $P \emptyset = \{\emptyset\}$.

```
PowerSet(S)
	if size(S) == 0 
		return {0} 
	else 
		P0 = PowerSet(S(1:n-1)) 
		for i=1:size(P0) 
			P1(i) = [P0(i) S(n)] 
		end 
		return P0 Union P1
```
um ok


ex. Tower of Hanoi: Given three pegs A,B,C, and a tower of $n$ disks, initially stacked in decreasing size on peg A.
Objective: transfer the entire tower from A to C. 
Rules:
	(a) move only one disk at a time, 
	(b) never put a larger disk on top of a smaller. 
(Historical note: n = 8, original puzzle by Lucas. n = 64 the Tower of Brahma)
Example with 3 disks: (1-2-3). Move 1 to C. Move 2 to B. Move 1 to B. Move 3 to C. Move 1 to A. Move 2 to C. Move 1 to C. Thinking recursively: Move(1:n,A,C)

 