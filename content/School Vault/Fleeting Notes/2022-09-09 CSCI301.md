tags: #notes #fleeting
creation date: [[2022-09-09 Friday]] 15:00:11
description:: learning java, asynch

doing the lecture notes now
module 1, lesson 4 a,b,c, and d

## 4a. Java Program Execution
a brief introduction to Java program execution and life cycle

to do list
- program execution, life cycle
- control flow
- fundamental data structures
- structure of large programs
- user interaction
- persistent storage
- special topics
	- concurrent execution
	- distributed / network applications
	- regular execution, error handling

from source code to a running program
- source code
	- what we produce, human readable language
	- .java
- .class files
	- not human readable
	- intended input for java version machine
- interpreter / virtual machine
	- machine specific
	- java version machine aka java VM
	- turns the .class files into code that runs on the specific platform
	- virtual machine provides an environment to interpret code


example: hellow world / red button
javac 
- command for invoking the compiler
- c for compiler

from code to execution
- step 1: javac MyProgram.java
	- compiles source code to byte code
- step 2: java MyProgram
	- starts JVM, loads and runs byte code from .class files
	- classes and libraries are usually packaged ,jar archive files

JVM
- loads class files on demand
- starts execution
- executed commands in main method
	- may start additional, parallel threads
- terminates if done with main method and all other threads
- internally
	- operates execution [[Stack]] for methods and [[Heap]] for objects
	- performs garbage collection on heap to recycle memory
		- no references to object = not being used = can be thrown out
	- [ ] make data structures topic notes

Operating system
- runs JVM in a user process with own virtual address space
- provides memory
- provides access to devices for input/output e.g. keyboard, screen, etc

Whats next?
- look at RedButtonGUI.java for heavily annotated code to provide a brief introduction into Java programming


## 4b. Java Control Flow
The notion of sequence is fundamental
- at a conceptual level, hardwar executes low level basic instructions in sequence
- a program is transformed into a sequence of instructions for its execution
- each instruction is an indivicual, discrete entity

in Java
- semicolon - denotes end of command, separates commands
- curly braces - group a set of commands into a block
- text layout **does not** matter for Java compiler (but does for humans)

caveats
- missing/extra  semicolons ruin everything

##### methods
- a function
- a block of code inside a class with:
	- a name
	- a return type including void
	- parameters
	- local variables
	- commands

input/output
how does data get into a method?
- parameters, like local variables with external initialization
- fields, access to instance variables is shared among methods of an object
how do results get out of a method?
- return type
- parameters, if they are references
- fields

##### if then else
data dependent decisions
conditional execution

##### switch statement
useful if 1 general default case, n special cases
```Java
switch(variable), {...}
```
case by case enumerated as case x : ... break ;
multiple cases with same effect can share code
works with a variety of variable types
- byte char short int primitive types
- Byte Character Short Integer wrapper classes
- Enum enumerated types
- Strings  (since SE 7)
```Java
public static void main(String[] args) {
	switch(args.length) {
	case 0 : printErrorMsg();
		break;
	case 1: case 2:
		print Arguments(args);
		break;
	default: printArguments(args);
		break;
	}
}
```


##### loops
allows for repeated execution of code block
loop requires
- termination criterion
- notion of progress
3 equivalent variants
- for loop
- while koop
- do-while loop

caveats
- for loop condition directly followed by ; 
	- typo error tricky to spot
- progress variable does not proceed towards termination - infinite loop
- nested loops with mingled notions of progress

for loop java example
```Java
void printArguments(String[] args) {
	for (int i = 0; i < args.length; i++) {
		String str = i + "-th parameter: " + args [i];
		System.out.println(str);
	}
}
```
```Java
void printArguments(String[] args) {
	int i = 0;
	for (String s : args) {
		String str = i + "-th parameter: " + s;
		System.out.println(str);
		i++;
	}
}
```
while loop java example
```Java
void printArguments(String[] args) {
	int i = 0;
	while (i < args.length) {
		String str = i + "-th parameter: " + s;
		System.out.println(str);
		i++;
	}
}
```
do while loop java example
why use this?
"does the code once for sure, then can go back and do it again if necessary"
```Java
void printArguments(String[] args) {
	int i = 0;
	do {
		String str = i + "-th parameter: " + args[i];
		System.out.println(str);
		i++;
	} while (i < args.length);
}
```

##### Basic Exception Handling
what if execution hits an error situation?
control flow for normal vs exceptional situations?
java separates code for execution handling

key idea: "passing a hot potato along"
- method that hits a problem it cant handle returns by throwing an exception, ie control flow switches toward exception handling
- calling method can either "catch" and handle exception or pass it on
- working down the execution stack, this ultimately leads to a program termination with a failure message.

ex. NullPointerException
```Java
String name = null;
int n = name.length(); <- ERROR
...
Exception in thread "main" java.lang.NullPointerException
at Greeter.sayHello(Greeter.java:25)
at GreeterTest.main(GreeterTest.Java:6)
```
- if a variable does not refer to an object its value is null
- calling method on null value is not possible
- common programming error
- unless there is a handler, program exits with stack trace

catching exceptions
```Java
try
{
	//code that might throw an IOException
}
catch
{
	//take corrective action
}
```
corrective action can be
- notify user of error and open dialog with selection of remedies
- log error in error report file
- common but unsatisfactory: print stack trace and exit
```Java
exception.printStackTrace();
System.exit(1);
```
lame ^

The finally Clause
- cleanup needs to occur during normal and exceptional processing
```Java
try
{
	reader = new FileReader(name);
	...
}
//can add a catch block here too
finally
{
	if (reader != null) reader.close();
}
```

Checked and Unchecked Exceptions
exceptions can be compiler checked and unchecked
examples
- NullPointerException is not checked
- IOException is checked

unchecked - due to programming errors, compilers not gonna do anything about it
checked - foreseeable problems the compiler finds

two approaches to dealing with checked exceptions
- propagate - declare the exception in the method header
- handle - catch the exception with the catch, finally, code from before
hot potato

propagating - declaring checked exceptions
```Java
public void read(String filename) throws FileNotFoundException
{
	FileReader reader = new FileReader(filename);
	...
}
```

i dont get why you would propagate like this, i guess if the error doesnt matter?

summary
- control flow -  sequence, loops, conditional execution
- method calls - getting data in and out of methods
- normal operation vs exception handling


## 4c. Structure of Java Programs
note: this video does not cover modules, will need to check another tut for that, some linked in blackboard page for 1.4c

How do we structure large programs?
- at a conceptual/design level -> will talk about more later
	- object oriented design, class design
	- software design patterns and software architecture
- at a language level, Java offers
	- Packages reside in directories, get packed into libraries (jar files)
	- Classes reside in files
	- Methods reside in Classes

##### methods
- functions
- talked about alrdy
- a method with different number of parameters (and different types) counts as different from another method, even with same name
- methods reside inside a class
```Java
//create method inside class MyClass
int mymethod(int i) {
	return i;
}

//instantiate an object of class MyClass
MyClass c = new MyClass();

//call method mymethod or object c
c.mymethod();
```
special case: call a static method in a class
```Java
static int mymethod(int i){
	return i;
}

//call directly using class name
//this method can only take advantage of static variables,
//not instance variables
MyClass.mymethod();
```

##### classes and objects
class name and file name needs to match
- 1 class 1 file (usually)
- special case: inner class within another class
- special case: anonymous classes, we'll see that later

class integrates data and algorithms
- several class variables of various kinds
- several methods

encapsulation / data hiding / information hiding
- methods are publicly available (public) or secret (private)
	- reduces complexity when interfacing with a class
- hiding information like this also called "encapsulation"
- data / class variables are typically private and hidden
- methods mainly operate on class internal data

what is good class design?
- key question for later

common use case for classes: class is instantiated into object
- each instance has own set of instance variables
- code for methods is shared

special use case for classes: static code
static methods
- no instantiation necessary to call a method
- example: `public static void main(String[] args)`
- typically used for stateless functions, ex. `sqrt()` in Math
static variables
- no instantiation necessary to access variables
- much like shared variables, either globally or among instances of a class
- static variables are prime suspects for memory leaks!
	- garbage collection cant recognize if static variable that refers to an object is ever going to be needed again, never recycles memory that a static variable refers to
	- if you dont release the memory, it wont be released by garbage collection

##### packages
classes are grouped into packages
- package names are dot-separated identifier sequences
	- java.util
	- javax.swing
	- com.sun.misc
	- edu.wm.cs.cs301.slidingpuzzle
	- as seen in these examples, naming goes from most general to -> special
- add package statement to top of file
	- `package edu.wm.cs.cs301.slidingpuzzle;`
- class without package name is in default package
	- sloppy
	- not cool

full name of class = package name + class name
important for compiler that this full name is unique

package name must match subdirectory name
- edu.wm.cs.cs301.slidingpuzzle.FastPuzzleSolver.java
- must be in subdirectory:
	- basedirectory/edu/wm/cs/cs301/slidingpuzzle

always compile from the base directory
- `javac edu/wm/cs/cs301/slidingpuzzle/FastPuzzleSolver.java`
always run from the base directory
- `java edu/wm/cs/cs301/slidingpuzzle/FastPuzzleSolver`

Importing Packages
tedious to write or read full class names in code
`import` allows you to use short class name

```Java
import java.util.ArrayList;
...
ArrayList a;
//dont have to write out java.util.ArrayList a;
```

can import all classes from a package
- `import java.util.*;`
cannot import from multiple packages
- `import java.*.*;` <- no

if a class occurs in two imported packages, import is no help
```Java
import java.util.*;
import java.sql.*;
...
java.util.Date d;
//Date also occurs in java.sql, so have to specify full name
```

note: never need to import java.lang bc used commonly
imported by default

##### libraries
packages can be packed into libraries for use/reuse
libraries are archive files (suffix .jar)
not a java language mechanism

##### summary
- basic tools for structuring code
- methods - block of code
- classes - files
- packages - directories
- libraries - archives


## 4d. Primitive Types in Java
im getting tired of this its been 1h44min

eight primitive types
- byte
- short
- int
- long
- float
- double
finite range - be careful of underflow, overflow
floating point - not real values, finite subset - be careful of floating point round errors

conversion via typecast
```Java
float pif = 3.14F;
double pi = 3.14159265;

int x = (int)pi;
//x = 3

pif = pi;
//pif = 3.14.15927
//pif loses one decimal place of precision at the end
```

operations for floating point and integral types
comparison < <= >= > and equality == !=
unary sign + -
math operations + - * / %

for integral types, also
increment/decrement, ++ --

common in for loops
bitwise complement ~ and bitwise operations &, |, XOR: ^

for floating point type, also
special classes Math and StrictMath for common numerical methods
y = Math.sqrt(x);
y = Math.round(x);
static methods

7th type: boolean
true or false

operators
relational == !=
conditional && ||
complement !
conditional ? :
- `int y = (x > 3) ? 4 : 5`
- if x > 3, then y = 4, else y = 5

8th type: char for Character
2 bytes
technically integral type
range 0 to 65635
type cast to short, int possible
unicode encoding
- essentially a 1-1 mapping between numbers and letters
special cases: escape sequences
- \\n used for newline
- \\b used for backspace
- \\r used for return
- \\t used for tab
- \\\\ for backslash
- \\' and \\"

##### build data structures from primitive types
Array
- container for values of same type
- Subclass of java.lang.Object
- length of array is finite and fixed
- index range 0 to n-1

```Java
int[]a = new int[10];
int n = a.length;

int[] b = new int[n];
if (a == b) {...}
if (a.equals(b)) {...}
//^both check if points to same array in memory
if(Arrays.equals(a,b)) {...}
//^checks if contents is equal, this is what we usually want
```

with Arrays.equals(), ok for primitive types, careful if array of objects

##### objects
object as an instance of a class
- has an identity, has a state, has behavior
- created/instantiated with `new`
- deleted/removed by garbage collection

`Object o = new Object();`

identity
- results from location in memory
state
- fields (instance variables) defined in class
- possible: primitive types, arrays, references to objects
- typically initialized in constructor method
behavior
- defined by set of methods

yup its all coming back to me getting robotics flashbacks

##### strings
array or object?
- java.lang.String is a subclass of Object
contains sequence of characters
indexation starts at 0
"" is the empty string of length 0, different from null

methods
- length()
- charAt()
- substring()
	- "Hello".substring(1,3) is "el"
- equals()
	- == only compares if references are identical
	- dont use ==

concatenation
- combine strings with +

strings are immutable
- cant change content
- implies generation of many (temporary) strings
- workaround: StringBuffer class
	- but error prone
	- also idk what this is and idc

caveats
- misunderstanding of reference and object

operations
extracting content
- StringTokenizer
	- countTokens()
	- hasMoreTokens()
	- nextToken()
parsing strings into primitive types
- use static parse method
	- Integer.parseInt()
	- Double.parseDouble
	- throws a number format exception if string does not contain a number
other useful classes for strings
- java.util.Scanner
- java.lang.StringBuffer

summary
- primitive types as basic building blocks
	- integral float boolean
- type cast between types
- common numerical operations
- building data structures in 2 ways
	- container for values of same type: Arrays
	- container for values of various types: Objects
	- note: arrays are objects in Java


OK IM DONE I GUESS THAT WAS USEFUL I WISH WE HAD CLASS BECAUSE I SPENT 2:21:19 WRITING THIS AND DID NOT NEED TO!