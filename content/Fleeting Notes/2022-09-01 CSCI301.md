tags: #notes #fleeting
creation date: [[2022-09-01 Thursday]] 07:59:37
description:: syllabus overview, project 0

software development
### Overview - what this is really all about
rumors
"brutal but most rewarding"
"lot of work but not overly difficult"
if you are better organized and plan your code out and put time into it you wont spend lots of time doing a lot of work fixing code
from catalog: "An introduction to **principled software development**, emphasizing **design at the module level** as well as tools and techniques."
about organizing code, but not on the architectural level
bird house vs skyscraper: learning how to build each
typical class assignments are like a bird house, not the real thing, doesnt have the structure/foundation to stay up

classes in cs
data structures and algorithms - best practices focusing on efficiency
software dev - working on existing code base, **scale is too large to know details of all existing code**, focusing on structure and best practices, getting a working solution on time, quality code
software engineering - continuation of this class, working in a team instead of solo, full dev process

working alone
- normally working in teams of 8-12 people, daily standup meetings
- "development is a team sport"
- for this class you write all the code yourself
- good to talk with other students

working on existing code base
- another programming language, java in this class
- "when you join a new team, programming languages come and go"
- why not read those "learning to code with java" books? too slow, too much stuff you already know
- learning to deal with complexity, size
- learning to appreciate documentation
- learn to **systematically automate testing**

reasonably clear problem spec
- "filling in the blanks"
- recognizing design and solution space
- getting a working solution on time

scale is too large to know details of all existing code
- learn to work with abstraction and interfaces
- being able to interact with code through interfaces without knowing how that code really works
- learn to work with tools that handle large code bases
- looking at different parts of code, navigating through code bases to understand specifications

Project 1 - small scale java application
- getting started with java eclipse and git
- 2048

Project 2-7 - one series of tasks on a single java project

2 - start with existing maze program, add functionality
3-5 - restructure code base, add abstractions, new algorithms, refactoring
6 - move into an android app, create new user interface for android
7 - port program into android

what do we learn
- general sw development
- object oriented design
- test driven design - automated testing, refactoring
- key concepts of OOP - polymorphism encapuslation interfaces inheritance
- UI development - separation of design and implementation
- parallel threading
- java programming - desktop and android, OO, UI, threads
- tools - IDE, **Git**, docu with **JavaDoc**, debugging, unit testing with **Junit**, code coverage with **Eclemma**, static code analysis with **PMD**, **Spotbugs**, developing with an emulator with **Android Studio**

see calendar in blackboard
add to notion v
 - [x] project zero - familiarize with git and gitlab
 - [x] piazza https://piazza.com/class/l6qldxbpfse7m4/


### Version Control with Git and Gitlab
- working on a long term project
- how do you prevent data loss and make backups?
	- could save lots of copies and go back to a previous version
	- (note: william and mary offers cloud storage)
	- eventually full copies will become too much, and theres lots of redundancy
	- working as a team is painful

3 variants of a version control system (vcs)
- local - use db to keep track of changes, delta-based vcs
- centralized - use db on a network server, sync with network vcs, commit changes
	- what if people work on the same file on the same lines? conflicts - whoever commits second has to resolve the conflict and decide which change is used
- distributed - local db mirrors the full repository and its history, every machine has a full copy, full backups if server dies
	- commit to local vcs
	- push from local to upstream vcs
	- allows for different types of workflows

git - command line interface
- figure out how to use git in eclipse

github, gitlab - hosts upstream repositories

git
- point of view - stream of snapshots
- keeps a series of snapshots to keep track of changes, no duplicate files
- many operations are purely local - fast
- checksum SHA-1 hash keys used as ids for files and folders "if you see those long string names"

3 states for a file
- committed - data is safely stored in local
- modified - file changed, not yet committed to local
- staged - modified file is marked as the current version to go into the next commit
	- why? because some changes only work in combination with others
	- ex. file A and B affect each other, need to be staged to commit together

the basic (local) git workflow
- modify files
- selectively stage changes you want to be part of next commit
- commit

how do we make sense of this in terms of a team?
![[Pasted image 20220901091321.png]]

terminology
- trunk - main line of development, "master branch" or "main branch"
- tag - a release, a full snapshot of a version that is not supposed to be changed
- branch - side tracks to the trunk usually from maintenance, bug fixes
- merging occurs when one wants to incorporate improvements from a branch into the trunk
- pull request aka a merge request - request to merge a branch into main

typical workflow
- sync with repository
- fetch and merge (pull) latest version from server
	- manually resolve conflicts with your own code, if conflicts appear from others' code*
- do all your work
- stage changes
- commit changes into local
- push batch of changes into repository

\*how do we minimize these conflicts?
- agree on who does what
- push often to prevent huge conflicts, only small


scalability
- build a hierarchy
- each dev has a branch off of main
- each dev makes pull requests to main
- only a dedicated coordinator can do merges to main
- each dev runs tests before pull request, and/or others do code review

project 0 is a "throwaway project" for learning git and making versions

files you should store in a VCS
- generally: what is necessary for the project
- source code - .java...
- tool config files - .gradle...
- infrastructure code
- other - readme, license

common rule for team work
- only push source code that compiles with no errors

files you should not store in a VCS
- generally - files that are team member specific or automatically generated
- dependencies, log files, hidden system files, personal config, non text based documentation, sensitive information
- use .gitignore in the root folder to ignore files
  
gitlab comes with an issue tracker, task board for organizing work
- helps organize who does what, deadlines, issues, tags
- for a single person, can be used for time management
- for a team, can be used for coordination and communication
- for a class like this, helps with deadlines, breaking up assignment into pieces

reflection
- how long did it take me to do certain tasks?
- what were red flags in the assignment? how did i solve these problems? what should i do in the future to prevent issues?

ran out of time could look at last couple slides


### Syllabus notes, project zero notes

For project assignments, you will work with Gitlab repositories hosted by WM IT at code.wm.edu.

For project 0, which is a simple preparation project to familiarize yourself with Eclipse and Git, I have created your project 0 repository and added you as a member of your project. Therefore you should see an invitation email. I am writing this post to let you know that this is not a spam or phishing email. The email was sent to your account @email.wm.edu.

So if you go to code.wm.edu, you'll need to sign in with the W&M CAS system.

Your project repository is hosted under 

https://code.wm.edu/CS/301/2022-fall-class-with-all-sections/project-0-the-red-button

If you can't access your repo, please let me know. 

The corresponding assignment is posted on the CS 301 blackboard site under Project assignments. 