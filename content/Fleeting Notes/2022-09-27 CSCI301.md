tags: #notes #fleeting
creation date: [[2022-09-27 Tuesday]] 11:01:03
description:: graph algorithms, boruvkas algorithm

discussing graph algorithms and boruvkas algorithm in particular for project 2

[[CS301_M2L6_GraphAlgorithms_PresentationSlides.pdf]]
## Graph Algorithms

##### Graphs and Minimal Spanning Trees
Graph G = (V,E)
- V set of vertices
- E set of edges
- here: undirected, edges can carry a numerical weight or cost

Graph concepts
- reachability
	- path from node v to w
- minimal spanning tree
	- subset of edges such that all vertices are connected, ie for all nodes v and w there exists a path from v to w and vice versa
	- minimal: sum of weights is minimal

##### Search Algorithm
Given an undirected graph G
- How can you find a spanning tree?
	- Depth-First-Search
		- Starting at some node, explore the graph only via edges that lead to then new, unvisited nodes. Follow path as far as you can, backtrack if node does not have any new adjacent nodes.
	- Breadth-First-Search
		- Same as DFS but we keep a queue of current edges and explore edges to new nodes in the order we recognize them.
- But how can find a minimal spanning tree?
	- Prim's algorithm
	- Kruskal's algorithm
	- and more
	- these two are "greedy algorithms"

##### Prim's Algorithm
also Jarnik or Prim-Jarnik Algorithm
origin: Jarnik 1930, Prim 1957, Dijkstra 1959
greedy algorithm for minimal spanning tree

idea
- grow a tree by adding cheapest edge to connect another node
- has a frontline between known and unknown nodes
- adds cheapest edge across frontline

video example https://en.wikipedia.org/wiki/File:MAZE_30x20_Prim.ogv

procedure
- input
	- non-empty connected weighted graph G
- initialize
	- V' = {x}, for some arbitrary starting point x in V, E' = {}
- repeat until V' = V
	- choose an edge {u,v} with minimal weight such that u is in V’ and v is not (if there are multiple edges with the same weight, any of them may be picked)
	- add v to V', and {u,v} to E'
- output
	- V' and E' describe minimal spanning tree
i dont get this but ok

##### Kruskal's Algorithm
origin: Kruskal 1956
greedy algorithm for minimal spanning tree

idea
- grow trees by adding cheapest edge that connects and thus merges two trees

procedure
- see slide 8 in the presentation idc to write it all out again

"Point of view is worth 80 IQ points"
-Alan Kay

some points of view make a problem much easier to solve
what different terms can we think of these graphs as?
can we think of these mazes as [[Matrix|Matrices]]?


##### Trees, Forests, and Mazes
How to generate a Maze?
- think of a set of possible positions V in a space
- need a path from any position x to any other position y
- do not want too many paths or maze gets boring...

Metaphor
- think of walls between all positions V
	- all walls start as built, just a grid of squares
- bulldozer starts at some node, and creates paths

an edge in a graph represents, able to move between these nodes
a wall in a maze represents, not able to move between these nodes
generating a maze = creating a spanning tree

Maze generation seen as a graph problem
- positions are the set of nodes V
- edges are possible connections paths of length 1 between nodes
- spanning tree is a graph that
	- has a path from **any** position x to **any** other position y
	- **does not have a single edge to spare, or it falls apart**
- minimal?
	- concept of weights not necessary here $\rightarrow$ all weights set to 1


##### Randomized Algorithms
maze needs irregular construction
- dont want the maze to be predictable or its boring
- aside: weights dont matter, all weights = 1

solution
- randomize decisions
- use random number generator

decision
- which edge to pick next

in DFS/BFS algorithms
- current node v selected via DFS or BFS
- for node v: randomly pick an edge to some new node

in Prim's algorithm: which edge to pick next
- if all weights equal, select random edge from frontier set

in Kruskal's algorithm: which edge to pick next
- if all weights equal, select random edge to connect trees


moving on to next slideshow

[[M2L15_boruvkasalgorithm.pdf]]
## Boruvka's Algorithm

##### Graphs and Minimal Spanning Trees
Graph G = (V,E)
- V set of vertices, E set of edges
- here: undirected, edges can carry a numerical weight or cost

Graph concepts
- reachability
	- path from node v to w
- minimal spanning tree
	- subset of edges such that all vertices are connected, ie for all nodes v and w there exists a path from v to w and vice versa
	- minimal: sum of weights is minimal
	- typical assumption: weights are unique

##### How to generate a Minimal Spanning Tree (MST)?
Observation
- if you have n already connected components which are trees and m left over edges connecting these (ie for each edge their end nodes are in different components), then you need to select n-1 out of m edges
- you can work towards an MST by adding one minimum weight (cost) edge connecting 2 components that are separate so far. this reduces the problem to n-1 trees and at most m-1 left over edges

for MST:
- Select cheapest option at hand (locally), pick the cheapest edge
- Never connect nodes that are in the same component
	- as they are already connected

variants of this idea
- Prim
	- "grow a single tree"
	- select your favorite component and grow it by adding edges and thus nodes to it
	- so: iterate over subset of edges expanding a single component
- Kruskal
	- "grow a forest by growing one tree each step"
	- select the cheapest left over edge and connect the components
	- so: iterate over edges merging any 2 components
- Boruvka
	- "grow a forest by growing each tree each step"
	- select the cheapest edge for each component and connect the components.
	- so: iterate over components and for each merge it with one adjacent component by selecting the cheapest edge

##### How do unique edge weights prevent cycles?
unique edge weights are useful because they prevent cycles/loops
how they do it:
- pick the cheapest edge leacing the component
- say it leads to B, weight 10
- only chance for B to have another edge
	- weight < 10
	- since weights are unique, there are no equal weights, so there is no confusion on which one is the cheapest
- edges are undirected, so could at most go back one

best way to learn new algorithms is to draw up examples and solve them using the algorithm

the algorithm
init
find cheapest edge for each component
check termination

##### Trees, Forests, and Mazes
How to generate a maze?
- think of a set of possible positions V in a space
- need a path from any position x to any other position y
- do not want too many paths or maze gets boring...

point of view
- think of walls between all positions V
- each node is isolated and in its own set
- if we remove a wall, we merge the sets the neighboring nodes belong to
- if we remove neough walls such that all nodes belong to one set, we have a maze where all positions can be reached from another

so
- removing a wall is the same as adding an edge to a graph
- want a random maze - pick random, but unique, weights


moving on to a third slideshow for some reason

[[CS301_M2L2_Pseudocode_PresentationSlides.pdf]]
## The Pseudocode Programming Process

see [[Code Complete]] for more on this
from blackboard:
Steve McConnell describes the Pseudocode Programming Process in his book in Chapter II.9 (Code Complete). The key idea is to do this in 2 steps: 1) use comments in a Java class to write up the procedure on how to solve a problem in plain English, but structure your steps into methods; 2) once your thought process is complete and you worked it all out, translate your comments into code. This section elaborates this concept in further detail.

i dont think im gonna write out a lot for this one

high-level method design contians
- the responsibility/purpose of the routine
- the information the routine will hide
- inputs to the routine
- outputs from the routine
- preconditions that are guaranteed to be true before the routine is called
- postconditions that the routine guarantees will be true before it passes control back to the caller

low-level method design
- key idea: separate detailed design from coding
- design
	- write up how the method works in pseudocode
	- think it through, do not forget cases, clarify I/O
	- does not interfere with coding issues
- once written, write code for it
- pseudocode $\rightarrow$ comments, no need for more
- in other words: "write comments first!"

on writing pseudocode
- makes reviews/adjustment easier
- supports the idea of iterative refinement
- makes changes easier (before coding)
- minimizes commenting effort
- easier to maintain than other forms of design documentation

##### Pseudocode Programming Process PPP
Starting point: Given high-level design
Step 1: Check prerequisites (job is well-defined, required)
Step 2: Name the routine
- "if you cant name the routine then you dont understand it enough"
Step 3: Decide how to test the routine
Step 4: Check for existing solutions (reuse code, ideas)
Step 5: Consider error handling
Step 6: Consider efficiency (no premature optimization)
Step 7: Check for existing data types, algorithms
Step 8: Think about the data (data types, what to store)
Step 9: Write/refine description in pseudocode
Step 10: Check/review pseudocode
- yourself, ask someone else
- make sure everything is clear to you before you start coding
Iterate: try a few ideas and keep the best!

![[Pasted image 20220927121234.png]]
from Code Complete

there's also a good checklist in the slides im not gonna write it out

"dont fall in love with your first idea"

end of class