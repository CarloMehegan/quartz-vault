tags: #notes #fleeting
creation date: [[2022-10-04 Tuesday]] 11:00:26
description:: like 4 slideshows on testing

cant find slides
## Can Software Development be fun?
aftercare from project 2 ptsd

On fun
- When a teacher says "This is going to be fun" it isn't
- How does it feel to work on coding assignments?

Fun in software dev
- This is the hard way
	- define success as "my program is fully implemented and works correctly!"
- This is an alternative
	- create a sequence of meaningful steps towards ultimate goal
	- check a box when you complete a step
	- ideally: at the end of the day, stop after completing a step, do not start another one and then leave in between

An analogy
- jigsaw puzzles
- whats the fun in this?
- the last moment when the puzzle is done, or the process?
- over 100 puzzle pieces, how would you graph the fun?

What do former CS students say who work in tech
- "There is always something new to learn in my job"
- "I learn something new every week"
- "One thing I know for sure: I'll figure it out"
- "If I stop learning in my job, I move on and change teams or employers"
- You never stop seeing new concepts

[[CS301_M2L3c_TestingMcConnellTricks_PresentationSlides.pdf]]
## Steve McConnell's Bag of Testing Tricks
[[Code Complete]]
Input
- Incomplete testing
	- not all inputs can be tested, need to make choices
	- corner cases
	- pick inputs that differ
	- thing of input as a space of possible things, cut it up
- This idea shows up in various ways
	- input partitioning
	- picking representatives across equivalence classes
	- error guessing
- We'll focus on testing a single method

Structured Basis Testing
- related: McCabe's cyclomatic complexity
- Calculate lower bound for number of paths (execution paths)
	- More possible paths, more complexity
	- 1 Start with 1 for straight path through method
	- 2 Add 1 for each of the following; if, while, repeat, for, and, or, etc
		- places where code diverges into different paths
	- 3 Add 1 for each case in a switch statement
		- default case counted with straight path
- Create set of tests to cover calculated set of paths
	- create a test per path
	- could be like a lot
	- what if it has like 27 paths?
		- sus
		- may be a sign to rewrite to reduce complexity

Data Flow Testing
- Data can exist in one of 3 states
	- defined = data initialized but not used yet
	- used = data has been used for computation
	- killed = data was once defined but is undefined now
- and to describe enter-exit method calls
	- entered = control enters a method, initialized variable
	- exited = control exits a method, assigned a return value
- Key idea
	- normal operation = defined -> used -> killed
	- other sequences (combinations) are suspicious works for code reviewing and testing

Suspicious combinations
- defined and then
	- defined: variable should not be set twice
	- exited or killed: variable is defined but not used
- entered and then
	- used or killed: variable needs to be defined beforehand
- killed and then
	- killed: variable should be not killed twice
	- used: logical error, accessing freed memory
- used and then
	- defined: variable needs to be defined beforehand
this is good stuff
- Check suspicious combinations **before** testing
- Data flow testing
	- test all defined-used pairs
	- weaker variant: all definitions
- How to do this
	- list all defined-used pairs for a method
	- for each def-use pair that is not covered yet
		- create additional test cases

Systematic Partition Testing
- Useful when looking at code from outside
- Partition parameter/value ranges into groups that would have the same effect
- For each group create only one test case with a representative value chose from the equivalence set
- can use this to think about what we're doing in the process of testing

![[Pasted image 20221004112635.png]]
shows fringe cases in the input

Error Guessing
- Based on past experience, tester guesses what cases the implementation may not handle correctly
- Common errors
- Common pitfalls
- Edge cases, boundary values
- Corner cases, exception handling

Boundary Analysis
- Check cases around limits and extreme cases
- Ex Check for off by one errors
	- check cases with max-1, max, and max+1
- Ex Combinations of extreme values
	- what if all factors in a product are large; negative; zero
	- what if all strings puched into a data structure are extremely long

Classes of Bad Data
- Typical bad-data test cases include
	- too little data or no data
	- too much data
	- wrong kind of data or invalid data
	- wrong size of data
	- uninitialized data

Classes of Good Data
- Typical good-data test cases include
	- nominal cases--middle of the road, expected values
	- minimum normal configuration
	- maximum normal configuration
	- compatibility with old data
- Structured basis testing typically covers good data cases

More tricks
- Use test cases that make hand checks convenient
	- values like 10,000 are easier to hand check than like 12094, and are usually just as good
- Goes back to oracle problem
	- given a test case, what is the correct answer?
	- how can you reliably get that answer?

Final check list on test cases from Steve McConnell
1. Does each requirement that applies to the class or routine have its own test case?
2. Does each element from the design that applies to the class or routine have its own test case?
3. Has each line of code been tested with at least one test case? Has this been verified by computing the minimum number of tests necessary to exercise each line of code?
4. Have all defined-used data-flow paths been tested with at least one test case?
5. Has the code been checked for data-flow patterns that are unlikely to be correct, such as defined-defined, defined-exited, and defined-killed? 
6. Has a list of common errors been used to write test cases to detect errors that have occurred frequently in the past? 
7. Have all simple boundaries been tested: maximum, minimum, and off-by-one boundaries? 
8. Have compound boundaries been tested—that is, combinations of input data that might result in a computed variable that's too small or too large?
9. Do test cases check for the wrong kind of data—for example, a negative number of employees in a payroll program? 
10. Are representative, middle-of-the-road values tested? 
11. Is the minimum normal configuration tested? 
12. Is the maximum normal configuration tested? 
13. Is compatibility with old data tested? And are old hardware, old versions of the operating system, and interfaces with old versions of other software tested? 
14. Do the test cases make hand-checks easy?
uhh ok

Summary
- Structured basis testing
- Data flow testing
- Input partitioning
- Error guessing, the usual suspects:
	- boundary analysis
	- classes of good data
	- classes of bad data
	- complex methods
- remember: errors are not distributed uniformly!


[[CS301_M2L3e_TestingOracle_PresentationSlides.pdf]]
not taking very thorough notes on this one so just look at presentation
## An Oracle for Testing
The Oracle Problem
- Key question
	- How do we decide if the observed program behavior is correct?
- Besides obvious cases where it's easy to tell when code failed, like when it crashes, how do we know beyond that that it is doing the right thing
- Up to us to decide what the code is supposed to do
	- How do we decide if the answer is not trivial?

Observation 1: We pick the question
- some questions may be easier than others
- for certain questions, answer feasible with manual calculations or with analytical formulas that are known and tracable
	- exact answer, upper/lower bound

Observation 2: Redundancy in Algorithms
- often many algorithms known to solve a problem
- start with a naive version that is straightforward
- use simple algorithm as oracle for production version

Observation 3: There is a lot of code out there
- use existing code as an oracle
- other dedicated frameworks, different programming environment, inefficient but readily available data structures

Observation 4: Consistency
- consistency is weaker than correctness but still useful
- ...

Observation 5: Bounds and necessary conditions
- bounds give limits to correct reults
- bounds help identify clear error cases
- in general: necessary conditions
	- "$\rightarrow$" weaker than "$\leftrightarrow$" but easier to obtain and implement
	- idk what this means

Summary
- Oracle requires some kind of redundant solution for specific test questions
	- looking for other sources, other code, etc. as a second, alternate implementation
- Outcome of Oracle needs to be documented in test case
	- documentation documentation
- Test code must be simple enough such that it need no testing on its own
	- vicious cycle
- There should be no magic involved!
- Transparency is important for credibility
	- how did you get the correct answer and why is it correct


My god another slideshow

[[CS301_M2L3f_TestingCoverage_PresetantionSlides.pdf]]
## Coverage Criteria for Software Testing
Testing is never complete, so when is enough?
- Obviously, if significant parts of the program structure are not tested, then testing is inadequate, not finished
- Leads to idea of "Coverage"
- How much of the code base did we cover with the execution?
- Starting point, measure how many lines of code are executed
	- leads to some percentage of lines covered
	- color highlighting for visualization in code editor
	- in Eclipse, Eclemma
	- this is the stupid button I keep pressing in eclipse
	- produces useful statistics
	- when you run all of the junit tests it should cover like everything

Various Control Flow Coverage Criteria Exist
1. Statement coverage
   single statement
   basic block
2. Branch coverage
   if/switch conditions, each branch
3. Condition coverage
   each basic condition evaluated to true and false
4. Path coverage
   execution paths through a method
5. Data flow
   define-used pairs of data (see earlier this class like 12 slideshows ago)
6. Function coverage
And More

![[Pasted image 20221004121053.png]]
heres a fun graph
im so tired

look at slides for this part with the graph its good i just dont wanna write it all

branch vs path coverage
if theres like 3 if statements then thats like 6 different branches but like 8 possible paths to traverse through all of them

branch vs condition coverage
with a lot of true false whatever condition coverage tries to be more efficient
does boolean algebra or something i guess so it doesnt have to go down every single path?

modified condition/decision coverage (MCDC)
requires that each basic condition be shown to independently affect the outcome of each decision
requirement for airborne systems software testing and stuff its a whole thing

what to do if coverage is bad, how do we get it higher can we get much higher
bad idea: quickly create/adapt tests to improve stats
good idea: check what is not covered, and why

skipping ahead bc out of time

summary
one thing to be clear on
code executino does not mean code is correct
if you had all the tests and then comment out all of the assert statements, youd still have high coverage but with bad tests