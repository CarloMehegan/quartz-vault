tags: #notes #fleeting
creation date: [[2022-10-11 Tuesday]] 11:04:25
description:: debugging, introducing project 3

project 2 is finished for everyone now
ways to have done it
- make a node class, store them in a linked list
- store IDs in a 2D array, make connecting IDs all the same when you break down a connecting wall
- multiple ways to solve the problem

test 2 due tomorrow just like last one (lame)
moving on to module 3 after

project 3 is coming up
first talking about debugging then will talk more about project 3

[[CS301_M2L4_Debugging_PresentationSlides.pdf]]
## Debugging
similar processes in all IDEs
using a debugger
think of coding execution as a movie, happens in sequence 1 frame/step at a time
debugger lets you look at each step, fast forward and stop at the parts you want to see
debugger lets you navigate forward through a program

##### Overview
- Debugging and its Issues
- Finding a Defect
- Fixing a Defect
	- finding vs fixing
- Psychological Considerations in Debugging
- Debugging Tools

##### Bugs vs Errors vs Faults
- Why is debugging worth a look
- Fastest programmers vs. Slowest programmers data
	- need to be careful when fixing things, can create defects when correcting defects

##### Defects as Opportunities
Can learn from mistakes
- the program you are working on
- the kind of mistakes you make
- the quality of your code from the pov of someone who has read it
- learn about how you solve problems
- how you fix defects

##### Stupid Strategies
an incomplete list
- Find the defect by guessing
	- debugging has a sense of guessing
	- becomes bad if it's **unsystematic**
- Dont waste time trying to understand the problem
- Fix the error with the most obvious fix
	- fixing one case that doesnt work by giving it its own method; likely there are other cases that dont work and will also give errors
- Debugging by superstition
	- claim that root causes are elsewhere; it's eclipse's fault (except like sometimes it is)

##### Finding a Defect
- From the scientific method
	- Gather data through repeatable experiments
	- Form a hypothesis that accounts for the data
	- Design an experiment to prove/disprove hypothesis
	- Prove/disprove hypothesis
	- Repeat as needed
- "The Scientific Method of Debugging"
	1. Stabilize the error
	2. Locate the source of the error ("the fault")
		1. Gather data that produces the defect
		2. Analyze the data and form a hypothesis about the defect
		3. Determine how to prove/disprove the hypothesis, either by testing the program or by examining the code
		4. Prove/disprove the hypothesis by using procedure 2.3
	3. Fix the defect
	4. Test the fix
	5. Look for similar errors
	6. How can you improve testing?

##### Stabilize the Error
- If difficult to reproduce
	- check list of prime suspects for random values during execution
		- variable used without initialization
		- variable refers to freed memory that is used elsewhere
		- multithreading: race conditions
		- multithreading: timing issues, order of execution
		- execution of program not memoryless, state in persistent storage
- Find a test case that reproduces the error each time executed
- Vary the test case to recognize which factor influences the error and which ones do not
- Simplify the test case to the smallest amount of gactors and data and functionality executed to produce the error

##### Locate the Source of the Error
- Brainstorm to produce a set of hypotheses
- Create experiments, additional tests toto obtain data to prove/disprove hypothesis and to locate the error

##### Tips for Finding Defects
an imcomplete series
- brainstorm possible hypotheses
- keep a notepad handy and make a list of things to try
- exercise the code in your unit test suite
- use available **tools**
	- interactive debuggers
	- memory checkers
	- picky compilers
	- static code checkers
	- many tools to work with that could find errors/give more information
- refine the test cases that produce the error
- **reproduce** the error in several different ways
- generate more data to generate more hypotheses
- use the reults of negative tests
- **narrow** the suspicious region of the code
- be suspicious of classes and routines that have had defects before
- check code with recent changes
- **expand** the suspicious region of code
- integrate incrementally
- check for common defects
- **talk to someone else** about the problem; confessional debugging

##### Brute Force Debugging
an expensive fallback, plan B
- design/review/recode
	- perform a full design and/or code review on broken code
	- throw away the whole program/suspected section of code and redesign/recode from scratch
- compile code
	- with full debugging info
	- at pickiest warning level
	- fix all compiler warnings
- testing
	- strap on a unit test harness and test suspected code in isolation
	- create an automated test suite and run it all night
- debugging
	- step through a big loop in the debugger manually until you get to the error
	- instrument code with print/display/logging info
- environment and tools
	- use a different compiler, program, environment
	- link/run code against special libraries or execution environments
	- replicate the end-user's full machine configuration
- bottom up
	- new code in small pieces, fully testing each piece as it's integrated

##### A Few Notes
on syntax errors, and if the editor is not smart
- dont trust line numbers in compiler messages
	- also check the lines around it, in particular the ones before
- dont trust conpiler messages
	- there is a problem, but the wording is sometimes misleading
- dont trust the compilers second message
	- once something is wrong (first message)
- divide and conquer
	- partition program into sections using comments and compile individual sections
- find misplaced comments and quotation marks
	- for C, C++, and Java, insert `/*"/**/` which will terminate either a comment of a string

##### Fixing a Defect
- Finding an error is hard, fixing it is often easy
	- seperate the two into separate tasks
	- pitfall: being easy makes us careless
		- fixing an error causes errors
- Recommendations
	- understand problem befroe fixing
	- understand program, not just problem
	- confirm the defect diagnosis
	- relax
	- save the original source code
	- **fix the problem, not the symptom**
	- change the code only for good reason
	- make one change at a time
	- check your fix
	- add a unit test theat exposes the defect
	- look for similar defects

##### Psychological Considerations
- **Debugging Blindness** thanks to "Pyschological Set"
- Brain makes shortcuts based on expectations
- Here:
	- students expect "while" condition to be checked at all times
	- programmer uses 2 variables SYSTSTS and SYSSTSTS instead of 1
	- programmer reads syntax the wrong way (curly braces, indentation, semicolons)
- Once understood, more clear why good programming practices are necessary
	- Formatting
	- Commenting
	- Variable names
	- Routine names
	- such that likely defects appear as variations and stick out
- "Pyschological Distance" can help us
	- ![[Pasted image 20221011115532.png]]

##### Debugging Tools
- Interactice Debuggers
- Others

##### Eclipse Debugger
- tutorials
	- check Mark Dexter's Tutorials on the eclipse debugger
- basics
	- step by step execution, break points
	- exploration of variables, data structures and stack frames
- advances
	- expressions
	- more on breakpoints
		- exception breakpoints
		- conditional breakpoints, hit counts
		- watch points (field breakpoints)
	- on the fly: change variables, hot code replacement



## Project 3

want to add a driver to the maze
control theory
think of a thermostat that controls heating
- observes, measures a system it controls
- uses **sensors** to obtain information
- control, makes decisions based on rules
- has the means to influence the system, **activators**

robot interface
- provides a level of abstraction for the driver
- "not operating the real thing on the floor, playing a game"

control
- normally a user clicks a button, control takes that and moves
- robot interfaces with control to make moves

control is split up into multiple parts for gui, maze, etc
StatePlay
- interacts with the map and drawing and stuff


where are walls?
- have a robot
- has a distance sensor in one direction
	- which face should it be mounted on?
	- how many do you need?
- driver asks robot, whats on your left hand side, etc ?
- robot relays sensor information
- sensor looks at floorplan to get this information, knows which way its facing, uses CardinalDirection
- driver thinks of direction as right left forward backward
- controller keeps track of x, y, cardinaldirection
	- cardinal direction is forward for the robot
	- aka sensor on the left side of robot will be one counterclockwise cardinal direction from robot's forward


Driver $\rightarrow$ Robot $\rightarrow$ Control $\rightarrow$ StatePlay
							  $\rightarrow$ Sensor $\rightarrow$ Floorplan

challenge is figuring out if the sensor (can be F B L R) and current forward direction (can be N S E W)
challenge for sensor is knowing what direction to check
challenge is to translate this into a cardinal direction to use on the floorplan
- this doesnt seem difficult sbould i be scared
- am i suppsed to implement all the combinations as a table why would i do that it can just be turning

then on the floorplan
if youre here and in facing this direction
then for the direction youre interested in
how far away is the wall



[[CS301_M3L1a_SWProcesses_PresentationSlides.pdf]]
## Software Processes
we got 5 min left why are we starting another slideshow

##### Software Process
- Most software development projects follow recognized stages from inception to completion
- ex. Waterfall model, Agile

##### Three Basic Steps in a SW Project
- Analysis
- Design
- Implementation
...

[[CS301_M3L1b_TDD_PresentationSlides.pdf]]
##### Spectrum for Iterative Approaches
![[Pasted image 20221011121804.png]]



prof gone for next 2 weeks
virtual office hours, asynch class, consultants still normal meetings (off for fall break though)