tags: #notes #fleeting
creation date: [[2022-10-24 Monday]] 11:00:08
description:: little-o, little-omega, starting Algorithms

big o big omega and stuff
uhh i should like read the textbook ab it

##### Little o
$f(x) = o(g(x))$ iff 
$\forall x \exists k$ : $f(x) > c*g(x)$ $\forall x \geq k$

alternative definition
$f(n) = o(g(n)) \leftrightarrow \lim_{n\rightarrow\infty} \frac {f(n)} {g(n)} = 0$

Big-O is $\leq$, little-o is $<$

##### Little omega $\omega$
$f(n) = \omega (g(n))$ iff
$\forall c \exists k$ : $f(n) > c*g(n)$ $\forall n \geq k$

alternative definition
$f(n) = \omega (g(n)) \leftrightarrow \lim_{n\rightarrow\infty} \frac {f(n)} {g(n)} = \infty$


##### Ordering functions example
$(logn)^m$
$n^2$
$n^3$
$(logn)^n$ can also be written as $log^nn$
$n^2logn$
$2^n$
$n^n$
$n^{logn}$ = compare to $2^n$ take log on both sides $log2^n, n$
$2^{2^n}$
$n!$
$2^{2^{n+1}}$ = compare to $2^{2^n}$, log of both sides $2^{n+1}, 2^n$
	also can be written as $(2^{2^n})^2$ so $2^{2^n}$ is the square root of $2^{2^{n+1}}$ !

ordered:

$(logn)^m$
$n^2$
$n^2logn$
$n^3$
$n^{logn}$
$2^n$
$(logn)^n$
$n!$
$n^n$
$2^{2^n}$


end of that section

## Algorithms
An algorithm is a finite set of precise instructions for performing a computing task or for solving a problem.

Components of an algorithm
- I/O input output (solution/answer)
- definiteness (well-defined steps)
- correctness (provably)
- generality (working for all possible inputs of a certain category)
- finiteness (no infinite loops)
- effectiveness (performable steps)
	- time, space, power, energy, real-time, QoS
	- focus on time and space as a function of problem (input) size
	- e.g. size of the database to search, number of cities to travel to, etc

We use the theory we learned to sum a series of numbers of operations and express them in terms of asymptotic notation (big-O).
Use the theory on sums, serie,s big-O, big-$\Theta$, little-o, to describe efficiency of a code

ex. find maximum in a list of n numbers
`7, 5, 2, 8, 1`
algorithm would look like: start with first number as the biggest number, compare to the second number, take the biggest, compare to the third, take the biggest, etc.

The steps
1. Set `currentMax` to first element.
2. Compare next integer to `currentMax`, and if larger replace
3. Repeat step 2 until all numbers have been visited
4. Print

The algorithm in pseudocode
int findMax ($a_1$,$a_2$,...,$a_n$: integers) 
max = $a_1$
for i in range 2, n
	if max < $a_i$, then max = $a_i$
return max

How fast is this algorithm?
- Linear time, because it visits each element