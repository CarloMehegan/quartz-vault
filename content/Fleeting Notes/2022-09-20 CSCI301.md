tags: #notes #fleeting
creation date: [[2022-09-20 Tuesday]] 11:02:00
description:: interfaces, polymorphism, inheritance

project 1 due yesterday
if you need extensions, every student gets one 1-week extension

test 1 due tomorrow
can take up to 5 times, reviewing what we've learned so far? idk

power went out

## Interfaces and Polymorphism continued
"many forms"
occurs when we have many classes that are related to each other by inheritance

"Inheritance lets us inherit attributes and methods from another class. Polymorphism uses those methods to perform different tasks. This allows us to perform a single action in different ways."
-w3 schools

Ability to select different methods of same name according to type of object

ok so basically when methods with the same name are able to do different things depending on the class of object

```Java
class Animal {
  public void animalSound() {
    System.out.println("The animal makes a sound");
  }
}

class Pig extends Animal {
  public void animalSound() {
    System.out.println("The pig says: wee wee");
  }
}

class Dog extends Animal {
  public void animalSound() {
    System.out.println("The dog says: bow wow");
  }
}
```

here we can call animalSound() for all of these classes and it works and does their own things

next is inheritance

## Inheritance
code sharing
avoiding redundancy
if code is shared, it is used more often
if code is used more often, there is more opportunity to find mistakes in it and fix them

inclusion hierarchy
inheritance useful as an ideology for managing large code bases

![[Pasted image 20220920112716.png]]

inheritance hierarchy
![[Pasted image 20220920112843.png]]

"with inheritance you get things for free, you can add, you can adjust, but you dont take away"
you get base methods, you can adjust them, you can add new methods, the only thing you cant do is remove methods/make them private/etc

quite powerful
if we wanted to run a method like getSalary on all employees, if the employees are paid by the hour or have a salary or are interns, doesn't matter, they all have a base version of this getSalary method and if they have a special case to calculate salary the method can be overridden and changed

##### SOLID principles in object oriented design
S - Single Responsibility principle
- when you design classes it is recommended to give every class **just one responsibility**
- classes are identifiable; easy to understand their function/responsibility when each class has only one
- dividing complexity
- concerns: effect of changes, complexity of a class, class reuse

O - Open/Closed principle
- software entities should be open for extension, closed for modification
- "as long as it works dont touch it"
- open for extension - adding on functionality
- closed for modification - the core part (that works already) is not touched

L - Liskov's Substitution principle

I - Interface Segregation principle
- many client-specific interfaces are better than one general purpose interface
- better to have multiple interfaces for special needs than one large interface
- "the bigger it is the harder it is to support all of it"
- have several, dedicated, smaller, specific-purpose interfaces

D - Dependency Inversion principle
- Depend upon Abstractions. Do not depend upon concretions
- "high-level modules/implementations should not depend on lower level modules/implementations. If that is the case â€” that our high-level modules depend on lower level modules means that there is an inversion of dependencies! Hence the name of the principle."
- "It protects us from a ripple effect from changes inside low level modules."
- how do we implement this principle specifically? i dont get it

##### Invoking superclass methods
cant access private fields of a superclass
- gives more control of how subclasses interact

when accessing private fields, normally would use a get method
be careful when doing this in subclasses

```Java
public double getSalary()
{
	return getSalary() + bonus; // ERROR--recursive call
}
```

if the Employee class has a getSalary function, and the salary field is private, then the Manager class could do something like the above, calling a get method to access the field. however this creates a loop

to avoid this use the `super` keyword
```Java
public double getSalary()
{
	return super.getSalary() + bonus;
}
```
super climbs up one level in the hierarchy
in this case, it will run Employee's version of getSalary, and not recursively call Manager's version of getSalary.


##### using super in subclass constructor
when we construct a subclass, we may want to use the superclass's constructor, and then add to it.

we can do this by calling super() in the first line of the subclass's constructor
```Java
public Manager(String aName)
{
	super(aName); // calls superclass constructor
	bonus = 0;
}
```
must be the first line
parameters can be passed through
after calling super, can continue initialization of subclass' other stuff


##### precondition
"what circumstances under which you perform well"
theres also postcondition
i dont really get it but seems useful
should look into more later
```Java
public class Employee
{
	/**
	Sets the employee salary to a given value.
	@param aSalary the new salary
	@precondition aSalary > 0
	*/
	public void setSalary(double aSalary) { 
		... 
	}
} 
```
is it an actual technical thing or a good practice thing




##### project 1 reflection
power is down so we cant do anything but we were gonna review an example project 1 submission

code review - an important skill
code readability is important

reflection on mine
- i shouldve used another private method for movement instead of copy pasting 4 times for each direction
	- still readable, but wouldve been better and i can think of a way to do it
- shouldve looked more into equals and hashCode
	- still not really sure how hashCode works, not sure equals was working right because new tiles still got added even if a move was made that didnt change the board
- couldve written longer comments outside of each method instead of dispersed comments throughout each method
	- or both really