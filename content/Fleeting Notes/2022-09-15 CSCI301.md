tags: #notes #fleeting
creation date: [[2022-09-15 Thursday]] 11:02:27
description:: equals() and hashCode(), interfaces and polymorphism

## equals(Object obj) and hashCode()

When are two objects equal and what does hashing have to do with it...

##### Equality of Objects

superclass of all objects - java.lang.Object
objects inherit these methods from java.lang.Object
- clone()
- equals(Object obj)
- hashCode()
- finalize()
- getClass()
- toString()
- for multithreading
	- wait()
	- wait(long timeout)
	- wait(long timeout, int nanos)

what is good semantics of clone()? - do they share info or complete duplicates?
	shallow clone - shares reference to same
	deep clone - copy of the object
	no general solution
for project 1, if you want to clone a state, should it share reference, or duplicate?
if you share, if one state makes changes, the others will too
for this project likely want to completely duplicate

what is good semantics of equals()?
	testing typically uses equals() to make sure operations are correct
how should we write State.equals() for project 1?

what should the toString() method print?

-> common to override these methods for adjustment


##### generate hashCode() and equals()
eclipse, for example, can generate boilerplate code based on selection of fields

self-referring to current object in python = self
self-referring to current object in java = this

im gonna fall asleep oh my god im so tired

just because eclipse generated doesnt make it correct, need to check
dont have to use generated code, can write whatever you think is best

equals should include check for null
check for if instanceof same class
etc

Source > Generate (bunch of different options)


##### requirements for equals method
reflexive: x.equals(x)
symmetric: x.equals(y) iff y.equals(x)
transitive: if x.equals(y) and y.equals(z), then x.equals(z)

x.equals(null) must return false
to access class specific fields, need to cast object reference

![[Pasted image 20220915113502.png]]
first 3 if statements are tests, then the real comparison comes after

##### What does hashing have to do with this?
Recall: Hashing
- data structure for a set of objects
- insert, find, modify, delete methods in O(1) constant time (usually)
	- constant time for searching

How hashing works (i dont remember)
- bins of short linked lists
- how do we decide which bins to pick
	- read contents of the object, do hash code calculation to get an index of which bin to put it in (also meaning which bin to search for it in)
- theres more to it but yeah yeah whatever
nice thing is java has all these data structures implemented for use
- still need to understand what they do but at least you dont have to implement yourself

whats in a hash
- HashSet: set of elements
- HashMap: key value pairs
	- ex. social security numbers can be keys used to lookup health records

java.util.HashMap<k,v> implements Map<k,v>
- boolean containsKey(Object key)
- V get(Object key)
- V put(K key, V value)
- V remove(Object key)

key idea
- map key to integer value, use value as index in an array, array contains linear lists of (key,value) pairs 
- hashCode(): maps objects to integer value
- equals(Object obj) identifies matching object in linear list

side constraint for keys a and b
- if a.equals(b), then a.hashCode() == b.hashCode()
- important: this is if then, not if and only if
	- if you gave everything the same hashcode, would still work, but wouldnt get the performance benefit
- what if all the elements were equal?
	- then they would only all go into the same bin

"what you see in the typical hashcode implementation is a weighted summation"
```Java
int h = 0;
for (int i = 0; i < s.length(); i++)
	h = 31 * h + s.charAt(i);
```
using 31 here - base 31 - the multiplying makes it "weighted"
if it was 10, and the string was "1234", you would see it resembles decimals

##### common pitfall with hashing
given
- a set S implemented with hashing
- S contains objects of type X
- X has private field f and get set methods for f
- we override equals and hashcode
- hashcode is based on fields of X, in particular, on f

scenario
- add object x to set S
- find x in S -> ok
- modify x using x.setf()
- find x in S -> fails

problem
- hashcode of x gives a different value after modification
- cant find x anymore

solution
- several solutions
- could remove x from hash, then update, then add it back in

Summary
- equals(Object obj)
	- common to override
	- eclipse supports boilerplate code, but you need to decide specifics
	- java goes by signatures; equals(YourClass y) is different
	- goes hand in hand with hashCode()
- hashCode()
	- used to locate the right bin for element in hash table
	- side constraint - equal objects go in same bin
	- general rule - if you override equals() you need to also override hashCode()
- Hashing support with HashSet, HashMap
	- update requires you to remove and reinsert modified element to be store it in the correct bin 


## Interfaces and Polymorphism
an interface
- is a list of method signatures
- can inclulde definition of constants
- is located in a file of same name
- can extend another interface (inheritance)
- can not be instantiated, does not include code

![[Pasted image 20220915120153.png]]

- an interface can be seen as a contract, as a role to play
- a class can implement one or more interfaces
	- by providing actual code for list of methods in each interface
	- it can play different roles; it can be used in different ways

![[Pasted image 20220915120313.png]]

key concept to develop generic reusable code.
separating class usage from class implementation has potential
- a single class can implement several interfaces
	- can be used in different ways
- multiple classes can implement the same interface
	- the unterface use calss can work with objects of different kind
- a vcariable can be of interface type
	- only interface methods can be executed

leads to polymorphism
Polymorphism
- refers to the ability to call *different methods of same name* based on the actual type of an object
what does this all mean?
- different classes with methods of the same name and we can call them
so what?

![[Pasted image 20220915120904.png]]
- when you call JoeDoe.drives() it doesnt matter if he is a richmond driver, williamsburg driver!
- can just call drives and go
- gives a lot of flexibility

Example taken from Chapter 4 of Object Oriented Design & Patterns C. Horstmann
![[Pasted image 20220915121049.png]]
JOptionPane.showMessageDialog(null, "Hello, World!");

![[Pasted image 20220915121123.png]]

works with "arbitrary" image file

looks difficult to implement drawing these windows
from a sw design point of view, delegate responsibilities of drawing the different elements of the windows
JOptionPane provides sufficient space, asks object to draw itself
- yields list of necessary methods
- leads to an Interface definition
- here: Icon interface type
- e.g. ImageIcon is one such class

```Java
public interface Icon
{
	int getIconWidth() ;
	int getIconHeight() ;
	void paintComponent(Component c, Graphics g, int x, int y) ;
} 
```


interface does not include implementation
interface does not list constructor method(s)
	not possible: constructor method contains name of class
class C implements interface I,
	If it declares that ( “c implements I“) and
	If it supplies implementation for all methods of I


![[Pasted image 20220915121654.png]]
ex. Mars icon
![[Pasted image 20220915121713.png]]

![[Pasted image 20220915121755.png]]
UML Class Diagram
https://www.visual-paradigm.com/guide/uml-unified-modeling-language/uml-class-diagram-tutorial/

this diagram shows that MarsIcon and ImageIcon implement the Icon interface
JOptionPane depends on Icon interface


next class talking about polymorphism
