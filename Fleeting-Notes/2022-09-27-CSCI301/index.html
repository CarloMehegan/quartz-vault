<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="tags: #notes #fleeting creation date: [[2022-09-27 Tuesday]] 11:01:03 description:: graph algorithms, boruvkas algorithm
discussing graph algorithms and boruvkas algorithm in particular for project 2"><title>ðŸª´ Quartz 3.3</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://carlomehegan.github.io/quartz-vault//icon.png><link href=https://carlomehegan.github.io/quartz-vault/styles.706bb6073ba85d26809f9096dae23a6b.min.css rel=stylesheet><link href=https://carlomehegan.github.io/quartz-vault/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://carlomehegan.github.io/quartz-vault/js/darkmode.d3b63235d6779582e069a9e8e0f62a2e.min.js></script>
<script src=https://carlomehegan.github.io/quartz-vault/js/util.5e39932758f9ecaf45fd54506ed61416.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://carlomehegan.github.io/quartz-vault/js/popover.6da9b273c092cc16fc1aa904d71a2163.min.js></script>
<script src=https://carlomehegan.github.io/quartz-vault/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://carlomehegan.github.io/quartz-vault/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://carlomehegan.github.io/quartz-vault/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://carlomehegan.github.io/quartz-vault/",fetchData=Promise.all([fetch("https://carlomehegan.github.io/quartz-vault/indices/linkIndex.ceb8a95725cfe40113a2d08a65709f40.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://carlomehegan.github.io/quartz-vault/indices/contentIndex.454c10603dcf6db14b5bc72df3624c0f.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://carlomehegan.github.io/quartz-vault",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://carlomehegan.github.io/quartz-vault",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'â€™':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/carlomehegan.github.io\/quartz-vault\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XYFD95KB4J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XYFD95KB4J",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://carlomehegan.github.io/quartz-vault/js/full-text-search.51f0b1753e9b30839d053f8a98cc20d1.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://carlomehegan.github.io/quartz-vault/>ðŸª´ Quartz 3.3</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><p class=meta>Last updated
Dec 6, 2022
<a href=https://github.com/jackyzha0/quartz/tree/hugo/content/Fleeting%20Notes/2022-09-27%20CSCI301.md rel=noopener>Edit Source</a></p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#graph-algorithms>Graph Algorithms</a><ol><li></li></ol></li><li><a href=#boruvkas-algorithm>Boruvka&rsquo;s Algorithm</a><ol><li></li></ol></li><li><a href=#the-pseudocode-programming-process>The Pseudocode Programming Process</a><ol><li></li></ol></li></ol></nav></details></aside><p>tags: #notes #fleeting
creation date: <a class="internal-link broken">2022-09-27 Tuesday</a> 11:01:03
description:: graph algorithms, boruvkas algorithm</p><p>discussing graph algorithms and boruvkas algorithm in particular for project 2</p><p><a class="internal-link broken">CS301_M2L6_GraphAlgorithms_PresentationSlides.pdf</a></p><a href=#graph-algorithms><h2 id=graph-algorithms><span class=hanchor arialabel=Anchor># </span>Graph Algorithms</h2></a><a href=#graphs-and-minimal-spanning-trees><h5 id=graphs-and-minimal-spanning-trees><span class=hanchor arialabel=Anchor># </span>Graphs and Minimal Spanning Trees</h5></a><p>Graph G = (V,E)</p><ul><li>V set of vertices</li><li>E set of edges</li><li>here: undirected, edges can carry a numerical weight or cost</li></ul><p>Graph concepts</p><ul><li>reachability<ul><li>path from node v to w</li></ul></li><li>minimal spanning tree<ul><li>subset of edges such that all vertices are connected, ie for all nodes v and w there exists a path from v to w and vice versa</li><li>minimal: sum of weights is minimal</li></ul></li></ul><a href=#search-algorithm><h5 id=search-algorithm><span class=hanchor arialabel=Anchor># </span>Search Algorithm</h5></a><p>Given an undirected graph G</p><ul><li>How can you find a spanning tree?<ul><li>Depth-First-Search<ul><li>Starting at some node, explore the graph only via edges that lead to then new, unvisited nodes. Follow path as far as you can, backtrack if node does not have any new adjacent nodes.</li></ul></li><li>Breadth-First-Search<ul><li>Same as DFS but we keep a queue of current edges and explore edges to new nodes in the order we recognize them.</li></ul></li></ul></li><li>But how can find a minimal spanning tree?<ul><li>Prim&rsquo;s algorithm</li><li>Kruskal&rsquo;s algorithm</li><li>and more</li><li>these two are &ldquo;greedy algorithms&rdquo;</li></ul></li></ul><a href=#prims-algorithm><h5 id=prims-algorithm><span class=hanchor arialabel=Anchor># </span>Prim&rsquo;s Algorithm</h5></a><p>also Jarnik or Prim-Jarnik Algorithm
origin: Jarnik 1930, Prim 1957, Dijkstra 1959
greedy algorithm for minimal spanning tree</p><p>idea</p><ul><li>grow a tree by adding cheapest edge to connect another node</li><li>has a frontline between known and unknown nodes</li><li>adds cheapest edge across frontline</li></ul><p>video example
<a href=https://en.wikipedia.org/wiki/File:MAZE_30x20_Prim.ogv rel=noopener>https://en.wikipedia.org/wiki/File:MAZE_30x20_Prim.ogv</a></p><p>procedure</p><ul><li>input<ul><li>non-empty connected weighted graph G</li></ul></li><li>initialize<ul><li>V&rsquo; = {x}, for some arbitrary starting point x in V, E&rsquo; = {}</li></ul></li><li>repeat until V&rsquo; = V<ul><li>choose an edge {u,v} with minimal weight such that u is in Vâ€™ and v is not (if there are multiple edges with the same weight, any of them may be picked)</li><li>add v to V&rsquo;, and {u,v} to E'</li></ul></li><li>output<ul><li>V&rsquo; and E&rsquo; describe minimal spanning tree
i dont get this but ok</li></ul></li></ul><a href=#kruskals-algorithm><h5 id=kruskals-algorithm><span class=hanchor arialabel=Anchor># </span>Kruskal&rsquo;s Algorithm</h5></a><p>origin: Kruskal 1956
greedy algorithm for minimal spanning tree</p><p>idea</p><ul><li>grow trees by adding cheapest edge that connects and thus merges two trees</li></ul><p>procedure</p><ul><li>see slide 8 in the presentation idc to write it all out again</li></ul><p>&ldquo;Point of view is worth 80 IQ points&rdquo;
-Alan Kay</p><p>some points of view make a problem much easier to solve
what different terms can we think of these graphs as?
can we think of these mazes as <a class="internal-link broken">Matrices</a>?</p><a href=#trees-forests-and-mazes><h5 id=trees-forests-and-mazes><span class=hanchor arialabel=Anchor># </span>Trees, Forests, and Mazes</h5></a><p>How to generate a Maze?</p><ul><li>think of a set of possible positions V in a space</li><li>need a path from any position x to any other position y</li><li>do not want too many paths or maze gets boring&mldr;</li></ul><p>Metaphor</p><ul><li>think of walls between all positions V<ul><li>all walls start as built, just a grid of squares</li></ul></li><li>bulldozer starts at some node, and creates paths</li></ul><p>an edge in a graph represents, able to move between these nodes
a wall in a maze represents, not able to move between these nodes
generating a maze = creating a spanning tree</p><p>Maze generation seen as a graph problem</p><ul><li>positions are the set of nodes V</li><li>edges are possible connections paths of length 1 between nodes</li><li>spanning tree is a graph that<ul><li>has a path from <strong>any</strong> position x to <strong>any</strong> other position y</li><li><strong>does not have a single edge to spare, or it falls apart</strong></li></ul></li><li>minimal?<ul><li>concept of weights not necessary here $\rightarrow$ all weights set to 1</li></ul></li></ul><a href=#randomized-algorithms><h5 id=randomized-algorithms><span class=hanchor arialabel=Anchor># </span>Randomized Algorithms</h5></a><p>maze needs irregular construction</p><ul><li>dont want the maze to be predictable or its boring</li><li>aside: weights dont matter, all weights = 1</li></ul><p>solution</p><ul><li>randomize decisions</li><li>use random number generator</li></ul><p>decision</p><ul><li>which edge to pick next</li></ul><p>in DFS/BFS algorithms</p><ul><li>current node v selected via DFS or BFS</li><li>for node v: randomly pick an edge to some new node</li></ul><p>in Prim&rsquo;s algorithm: which edge to pick next</p><ul><li>if all weights equal, select random edge from frontier set</li></ul><p>in Kruskal&rsquo;s algorithm: which edge to pick next</p><ul><li>if all weights equal, select random edge to connect trees</li></ul><p>moving on to next slideshow</p><p><a class="internal-link broken">M2L15_boruvkasalgorithm.pdf</a></p><a href=#boruvkas-algorithm><h2 id=boruvkas-algorithm><span class=hanchor arialabel=Anchor># </span>Boruvka&rsquo;s Algorithm</h2></a><a href=#graphs-and-minimal-spanning-trees-1><h5 id=graphs-and-minimal-spanning-trees-1><span class=hanchor arialabel=Anchor># </span>Graphs and Minimal Spanning Trees</h5></a><p>Graph G = (V,E)</p><ul><li>V set of vertices, E set of edges</li><li>here: undirected, edges can carry a numerical weight or cost</li></ul><p>Graph concepts</p><ul><li>reachability<ul><li>path from node v to w</li></ul></li><li>minimal spanning tree<ul><li>subset of edges such that all vertices are connected, ie for all nodes v and w there exists a path from v to w and vice versa</li><li>minimal: sum of weights is minimal</li><li>typical assumption: weights are unique</li></ul></li></ul><a href=#how-to-generate-a-minimal-spanning-tree-mst><h5 id=how-to-generate-a-minimal-spanning-tree-mst><span class=hanchor arialabel=Anchor># </span>How to generate a Minimal Spanning Tree (MST)?</h5></a><p>Observation</p><ul><li>if you have n already connected components which are trees and m left over edges connecting these (ie for each edge their end nodes are in different components), then you need to select n-1 out of m edges</li><li>you can work towards an MST by adding one minimum weight (cost) edge connecting 2 components that are separate so far. this reduces the problem to n-1 trees and at most m-1 left over edges</li></ul><p>for MST:</p><ul><li>Select cheapest option at hand (locally), pick the cheapest edge</li><li>Never connect nodes that are in the same component<ul><li>as they are already connected</li></ul></li></ul><p>variants of this idea</p><ul><li>Prim<ul><li>&ldquo;grow a single tree&rdquo;</li><li>select your favorite component and grow it by adding edges and thus nodes to it</li><li>so: iterate over subset of edges expanding a single component</li></ul></li><li>Kruskal<ul><li>&ldquo;grow a forest by growing one tree each step&rdquo;</li><li>select the cheapest left over edge and connect the components</li><li>so: iterate over edges merging any 2 components</li></ul></li><li>Boruvka<ul><li>&ldquo;grow a forest by growing each tree each step&rdquo;</li><li>select the cheapest edge for each component and connect the components.</li><li>so: iterate over components and for each merge it with one adjacent component by selecting the cheapest edge</li></ul></li></ul><a href=#how-do-unique-edge-weights-prevent-cycles><h5 id=how-do-unique-edge-weights-prevent-cycles><span class=hanchor arialabel=Anchor># </span>How do unique edge weights prevent cycles?</h5></a><p>unique edge weights are useful because they prevent cycles/loops
how they do it:</p><ul><li>pick the cheapest edge leacing the component</li><li>say it leads to B, weight 10</li><li>only chance for B to have another edge<ul><li>weight &lt; 10</li><li>since weights are unique, there are no equal weights, so there is no confusion on which one is the cheapest</li></ul></li><li>edges are undirected, so could at most go back one</li></ul><p>best way to learn new algorithms is to draw up examples and solve them using the algorithm</p><p>the algorithm
init
find cheapest edge for each component
check termination</p><a href=#trees-forests-and-mazes-1><h5 id=trees-forests-and-mazes-1><span class=hanchor arialabel=Anchor># </span>Trees, Forests, and Mazes</h5></a><p>How to generate a maze?</p><ul><li>think of a set of possible positions V in a space</li><li>need a path from any position x to any other position y</li><li>do not want too many paths or maze gets boring&mldr;</li></ul><p>point of view</p><ul><li>think of walls between all positions V</li><li>each node is isolated and in its own set</li><li>if we remove a wall, we merge the sets the neighboring nodes belong to</li><li>if we remove neough walls such that all nodes belong to one set, we have a maze where all positions can be reached from another</li></ul><p>so</p><ul><li>removing a wall is the same as adding an edge to a graph</li><li>want a random maze - pick random, but unique, weights</li></ul><p>moving on to a third slideshow for some reason</p><p><a class="internal-link broken">CS301_M2L2_Pseudocode_PresentationSlides.pdf</a></p><a href=#the-pseudocode-programming-process><h2 id=the-pseudocode-programming-process><span class=hanchor arialabel=Anchor># </span>The Pseudocode Programming Process</h2></a><p>see <a class="internal-link broken">Code Complete</a> for more on this
from blackboard:
Steve McConnell describes the Pseudocode Programming Process in his book in Chapter II.9 (Code Complete). The key idea is to do this in 2 steps: 1) use comments in a Java class to write up the procedure on how to solve a problem in plain English, but structure your steps into methods; 2) once your thought process is complete and you worked it all out, translate your comments into code.Â This section elaborates this concept in further detail.</p><p>i dont think im gonna write out a lot for this one</p><p>high-level method design contians</p><ul><li>the responsibility/purpose of the routine</li><li>the information the routine will hide</li><li>inputs to the routine</li><li>outputs from the routine</li><li>preconditions that are guaranteed to be true before the routine is called</li><li>postconditions that the routine guarantees will be true before it passes control back to the caller</li></ul><p>low-level method design</p><ul><li>key idea: separate detailed design from coding</li><li>design<ul><li>write up how the method works in pseudocode</li><li>think it through, do not forget cases, clarify I/O</li><li>does not interfere with coding issues</li></ul></li><li>once written, write code for it</li><li>pseudocode $\rightarrow$ comments, no need for more</li><li>in other words: &ldquo;write comments first!&rdquo;</li></ul><p>on writing pseudocode</p><ul><li>makes reviews/adjustment easier</li><li>supports the idea of iterative refinement</li><li>makes changes easier (before coding)</li><li>minimizes commenting effort</li><li>easier to maintain than other forms of design documentation</li></ul><a href=#pseudocode-programming-process-ppp><h5 id=pseudocode-programming-process-ppp><span class=hanchor arialabel=Anchor># </span>Pseudocode Programming Process PPP</h5></a><p>Starting point: Given high-level design
Step 1: Check prerequisites (job is well-defined, required)
Step 2: Name the routine</p><ul><li>&ldquo;if you cant name the routine then you dont understand it enough&rdquo;
Step 3: Decide how to test the routine
Step 4: Check for existing solutions (reuse code, ideas)
Step 5: Consider error handling
Step 6: Consider efficiency (no premature optimization)
Step 7: Check for existing data types, algorithms
Step 8: Think about the data (data types, what to store)
Step 9: Write/refine description in pseudocode
Step 10: Check/review pseudocode</li><li>yourself, ask someone else</li><li>make sure everything is clear to you before you start coding
Iterate: try a few ideas and keep the best!</li></ul><p><a class="internal-link broken">Pasted image 20220927121234.png</a>
from Code Complete</p><p>there&rsquo;s also a good checklist in the slides im not gonna write it out</p><p>&ldquo;dont fall in love with your first idea&rdquo;</p><p>end of class</p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/quartz-vault/Daily/2022-09-27-Tuesday/ data-ctx="Fleeting Notes/2022-09-27 CSCI301" data-src=/Daily/2022-09-27-Tuesday class=internal-link></a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://carlomehegan.github.io/quartz-vault/js/graph.abd4bc2af3869a96524d7d23b76152c7.js></script></div></div><div id=contact_buttons><footer><p>Made by Jacky Zhao using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, Â© 2022</p><ul><li><a href=https://carlomehegan.github.io/quartz-vault/>Home</a></li><li><a href=https://twitter.com/_jzhao>Twitter</a></li><li><a href=https://github.com/jackyzha0>Github</a></li></ul></footer></div></div></body></html>